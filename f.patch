diff --git a/packages/ports/src/ports/storage.rs b/packages/ports/src/ports/storage.rs
index 7bfde9d..8c5e032 100644
--- a/packages/ports/src/ports/storage.rs
+++ b/packages/ports/src/ports/storage.rs
@@ -189,6 +189,7 @@ pub trait Storage: Send + Sync {
     async fn get_pending_txs(&self) -> Result<Vec<L1Tx>>;
     async fn get_latest_pending_txs(&self) -> Result<Option<L1Tx>>;
     async fn has_pending_txs(&self) -> Result<bool>;
+    async fn has_nonfinalized_txs(&self) -> Result<bool>;
     async fn oldest_nonfinalized_fragments(
         &self,
         starting_height: u32,
@@ -197,6 +198,11 @@ pub trait Storage: Send + Sync {
     async fn fragments_submitted_by_tx(&self, tx_hash: [u8; 32]) -> Result<Vec<BundleFragment>>;
     async fn last_time_a_fragment_was_finalized(&self) -> Result<Option<DateTime<Utc>>>;
     async fn update_tx_state(&self, hash: [u8; 32], state: TransactionState) -> Result<()>;
+    async fn batch_update_tx_states(
+        &self,
+        selective_changes: Vec<([u8; 32], TransactionState)>,
+        noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+    ) -> Result<()>;
 }
 
 impl<T: Storage + Send + Sync> Storage for Arc<T> {
@@ -231,6 +237,7 @@ impl<T: Storage + Send + Sync> Storage for Arc<T> {
                 async fn get_pending_txs(&self) -> Result<Vec<L1Tx>>;
                 async fn get_latest_pending_txs(&self) -> Result<Option<L1Tx>>;
                 async fn has_pending_txs(&self) -> Result<bool>;
+                async fn has_nonfinalized_txs(&self) -> Result<bool>;
                 async fn oldest_nonfinalized_fragments(
                     &self,
                     starting_height: u32,
@@ -239,6 +246,11 @@ impl<T: Storage + Send + Sync> Storage for Arc<T> {
                 async fn fragments_submitted_by_tx(&self, tx_hash: [u8; 32]) -> Result<Vec<BundleFragment>>;
                 async fn last_time_a_fragment_was_finalized(&self) -> Result<Option<DateTime<Utc>>>;
                 async fn update_tx_state(&self, hash: [u8; 32], state: TransactionState) -> Result<()>;
+                async fn batch_update_tx_states(
+                    &self,
+                    selective_changes: Vec<([u8; 32], TransactionState)>,
+                    noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+                ) -> Result<()>;
         }
     }
 }
@@ -275,6 +287,7 @@ impl<T: Storage + Send + Sync> Storage for &T {
                 async fn get_pending_txs(&self) -> Result<Vec<L1Tx>>;
                 async fn get_latest_pending_txs(&self) -> Result<Option<L1Tx>>;
                 async fn has_pending_txs(&self) -> Result<bool>;
+                async fn has_nonfinalized_txs(&self) -> Result<bool>;
                 async fn oldest_nonfinalized_fragments(
                     &self,
                     starting_height: u32,
@@ -283,6 +296,11 @@ impl<T: Storage + Send + Sync> Storage for &T {
                 async fn fragments_submitted_by_tx(&self, tx_hash: [u8; 32]) -> Result<Vec<BundleFragment>>;
                 async fn last_time_a_fragment_was_finalized(&self) -> Result<Option<DateTime<Utc>>>;
                 async fn update_tx_state(&self, hash: [u8; 32], state: TransactionState) -> Result<()>;
+                async fn batch_update_tx_states(
+                    &self,
+                    selective_changes: Vec<([u8; 32], TransactionState)>,
+                    noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+                ) -> Result<()>;
         }
     }
 }
diff --git a/packages/services/src/state_committer.rs b/packages/services/src/state_committer.rs
index d8be22c..0b6f2d1 100644
--- a/packages/services/src/state_committer.rs
+++ b/packages/services/src/state_committer.rs
@@ -135,6 +135,7 @@ where
 
     async fn get_pending_transaction(&self) -> Result<Option<L1Tx>> {
         let tx = self.storage.get_latest_pending_txs().await?;
+
         Ok(tx)
     }
 
@@ -206,7 +207,11 @@ where
         }
     }
 
-    async fn resubmit_fragments_if_stalled(&self, previous_tx: L1Tx) -> Result<()> {
+    async fn resubmit_fragments_if_stalled(&self) -> Result<()> {
+        let Some(previous_tx) = self.get_pending_transaction().await? else {
+            return Ok(());
+        };
+
         let elapsed = self.elapsed_since_tx_submitted(&previous_tx)?;
 
         if elapsed >= self.config.gas_bump_timeout {
@@ -232,9 +237,10 @@ where
     C: Clock + Send + Sync,
 {
     async fn run(&mut self) -> Result<()> {
-        match self.get_pending_transaction().await? {
-            Some(previous_tx) => self.resubmit_fragments_if_stalled(previous_tx).await?,
-            None => self.submit_fragments_if_ready().await?,
+        if self.storage.has_nonfinalized_txs().await? {
+            self.resubmit_fragments_if_stalled().await?
+        } else {
+            self.submit_fragments_if_ready().await?
         };
 
         Ok(())
diff --git a/packages/services/src/state_listener.rs b/packages/services/src/state_listener.rs
index abc0373..c73f823 100644
--- a/packages/services/src/state_listener.rs
+++ b/packages/services/src/state_listener.rs
@@ -1,3 +1,5 @@
+use std::collections::HashSet;
+
 use metrics::{
     prometheus::{core::Collector, IntGauge, Opts},
     RegistersMetrics,
@@ -40,7 +42,16 @@ where
     async fn check_non_finalized_txs(&mut self, non_finalized_txs: Vec<L1Tx>) -> crate::Result<()> {
         let current_block_number: u64 = self.l1_adapter.get_block_number().await?.into();
 
+        let mut skip_nonces = HashSet::new();
+
+        let mut selective_change = vec![];
+        let mut noncewide_changes = vec![];
+
         for tx in non_finalized_txs {
+            if skip_nonces.contains(&tx.nonce) {
+                continue;
+            }
+
             // get response if tx is included in a block
             let Some(tx_response) = self.l1_adapter.get_transaction_response(tx.hash).await? else {
                 // not included in block - check what happened to the tx
@@ -48,9 +59,7 @@ where
                 match (tx.state, self.l1_adapter.is_squeezed_out(tx.hash).await?) {
                     (TransactionState::Pending, true) => {
                         //not in the mempool anymore set it to failed
-                        self.storage
-                            .update_tx_state(tx.hash, TransactionState::Failed)
-                            .await?;
+                        selective_change.push((tx.hash, tx.nonce, TransactionState::Failed));
 
                         info!(
                             "blob tx {} not found in mempool. Setting to failed",
@@ -60,9 +69,7 @@ where
 
                     (TransactionState::IncludedInBlock, false) => {
                         // if tx was in block and reorg happened now it is in the mempool - we need to set the tx to pending
-                        self.storage
-                            .update_tx_state(tx.hash, TransactionState::Pending)
-                            .await?;
+                        selective_change.push((tx.hash, tx.nonce, TransactionState::Pending));
 
                         info!(
                             "blob tx {} returned to mempool. Setting to pending",
@@ -75,10 +82,11 @@ where
                 continue;
             };
 
+            skip_nonces.insert(tx.nonce);
+
             if !tx_response.succeeded() {
-                self.storage
-                    .update_tx_state(tx.hash, TransactionState::Failed)
-                    .await?;
+                // todo dzematile sve na failed sa ovim nonce
+                noncewide_changes.push((tx.hash, tx.nonce, TransactionState::Failed));
 
                 info!("failed blob tx {}", hex::encode(tx.hash));
                 continue;
@@ -89,9 +97,8 @@ where
             {
                 // tx included in block but is not yet finalized
                 if tx.state == TransactionState::Pending {
-                    self.storage
-                        .update_tx_state(tx.hash, TransactionState::IncludedInBlock)
-                        .await?;
+                    // todo dzematile sve ostale na failed a ovu na included in block
+                    noncewide_changes.push((tx.hash, tx.nonce, TransactionState::IncludedInBlock));
 
                     info!(
                         "blob tx {} included in block {}",
@@ -103,9 +110,12 @@ where
                 continue;
             }
 
-            self.storage
-                .update_tx_state(tx.hash, TransactionState::Finalized(self.clock.now()))
-                .await?;
+            // dzematile sve ostale na failed a ovu na finalized
+            noncewide_changes.push((
+                tx.hash,
+                tx.nonce,
+                TransactionState::Finalized(self.clock.now()),
+            ));
 
             info!("blob tx {} finalized", hex::encode(tx.hash));
 
@@ -114,6 +124,16 @@ where
                 .set(i64::try_from(tx_response.block_number()).unwrap_or(i64::MAX))
         }
 
+        selective_change.retain(|(_, nonce, _)| !skip_nonces.contains(nonce));
+        let selective_change: Vec<_> = selective_change
+            .into_iter()
+            .map(|(hash, _, state)| (hash, state))
+            .collect();
+
+        self.storage
+            .batch_update_tx_states(selective_change, noncewide_changes)
+            .await?;
+
         Ok(())
     }
 }
diff --git a/packages/storage/src/lib.rs b/packages/storage/src/lib.rs
index 0c99a0a..f3b3d8f 100644
--- a/packages/storage/src/lib.rs
+++ b/packages/storage/src/lib.rs
@@ -126,9 +126,23 @@ impl Storage for Postgres {
         Ok(self._has_pending_txs().await?)
     }
 
+    async fn has_nonfinalized_txs(&self) -> Result<bool> {
+        Ok(self._has_nonfinalized_txs().await?)
+    }
+
     async fn update_tx_state(&self, hash: [u8; 32], state: TransactionState) -> Result<()> {
         Ok(self._update_tx_state(hash, state).await?)
     }
+
+    async fn batch_update_tx_states(
+        &self,
+        selective_changes: Vec<([u8; 32], TransactionState)>,
+        noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+    ) -> Result<()> {
+        Ok(self
+            ._batch_update_tx_states(selective_changes, noncewide_changes)
+            .await?)
+    }
 }
 
 #[cfg(test)]
diff --git a/packages/storage/src/postgres.rs b/packages/storage/src/postgres.rs
index a60abc6..b328ca9 100644
--- a/packages/storage/src/postgres.rs
+++ b/packages/storage/src/postgres.rs
@@ -469,6 +469,17 @@ impl Postgres {
         .has_pending_transactions.unwrap_or(false))
     }
 
+    pub(crate) async fn _has_nonfinalized_txs(&self) -> Result<bool> {
+        Ok(sqlx::query!(
+            "SELECT EXISTS (SELECT 1 FROM l1_blob_transaction WHERE state = $1 OR state = $2) AS has_nonfinalized_transactions;",
+            i16::from(L1TxState::Pending),
+            i16::from(L1TxState::IncludedInBlock)
+        )
+        .fetch_one(&self.connection_pool)
+        .await?
+        .has_nonfinalized_transactions.unwrap_or(false))
+    }
+
     pub(crate) async fn _get_non_finalized_txs(&self) -> Result<Vec<ports::types::L1Tx>> {
         sqlx::query_as!(
             tables::L1Tx,
@@ -531,6 +542,68 @@ impl Postgres {
         Ok(())
     }
 
+    pub(crate) async fn _batch_update_tx_states(
+        &self,
+        selective_changes: Vec<([u8; 32], TransactionState)>,
+        noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+    ) -> Result<()> {
+        let mut tx = self.connection_pool.begin().await?;
+
+        for change in selective_changes {
+            let hash = change.0;
+            let state = change.1;
+
+            let finalized_at = match &state {
+                TransactionState::Finalized(date_time) => Some(*date_time),
+                _ => None,
+            };
+            let state = i16::from(L1TxState::from(&state));
+
+            sqlx::query!(
+                "UPDATE l1_blob_transaction SET state = $1, finalized_at = $2 WHERE hash = $3",
+                state,
+                finalized_at,
+                hash.as_slice(),
+            )
+            .execute(&mut *tx)
+            .await?;
+        }
+
+        for change in noncewide_changes {
+            let hash = change.0;
+            let nonce = change.1;
+            let state = change.2;
+
+            let finalized_at = match &state {
+                TransactionState::Finalized(date_time) => Some(*date_time),
+                _ => None,
+            };
+            let state = i16::from(L1TxState::from(&state));
+
+            sqlx::query!(
+                "UPDATE l1_blob_transaction SET state = $1, finalized_at = $2 WHERE nonce = $3",
+                i16::from(L1TxState::Failed),
+                Option::<DateTime<Utc>>::None,
+                i64::from(nonce),
+            )
+            .execute(&mut *tx)
+            .await?;
+
+            sqlx::query!(
+                "UPDATE l1_blob_transaction SET state = $1, finalized_at = $2 WHERE hash = $3",
+                state,
+                finalized_at,
+                hash.as_slice(),
+            )
+            .execute(&mut *tx)
+            .await?;
+        }
+
+        tx.commit().await?;
+
+        Ok(())
+    }
+
     pub(crate) async fn _insert_bundle_and_fragments(
         &self,
         block_range: RangeInclusive<u32>,
diff --git a/packages/storage/src/test_instance.rs b/packages/storage/src/test_instance.rs
index 8339dcb..0dc7277 100644
--- a/packages/storage/src/test_instance.rs
+++ b/packages/storage/src/test_instance.rs
@@ -196,6 +196,7 @@ impl Storage for DbWithProcess {
             async fn get_pending_txs(&self) -> ports::storage::Result<Vec<L1Tx>>;
             async fn get_latest_pending_txs(&self) -> ports::storage::Result<Option<L1Tx>>;
             async fn has_pending_txs(&self) -> ports::storage::Result<bool>;
+            async fn has_nonfinalized_txs(&self) -> ports::storage::Result<bool>;
             async fn oldest_nonfinalized_fragments(
                 &self,
                 starting_height: u32,
@@ -204,6 +205,11 @@ impl Storage for DbWithProcess {
             async fn fragments_submitted_by_tx(&self, tx_hash: [u8; 32]) -> ports::storage::Result<Vec<BundleFragment>>;
             async fn last_time_a_fragment_was_finalized(&self) -> ports::storage::Result<Option<DateTime<Utc>>>;
             async fn update_tx_state(&self, hash: [u8; 32], state: TransactionState) -> ports::storage::Result<()>;
+            async fn batch_update_tx_states(
+                &self,
+                selective_changes: Vec<([u8; 32], TransactionState)>,
+                noncewide_changes: Vec<([u8; 32], u32, TransactionState)>,
+            ) -> ports::storage::Result<()>;
         }
     }
 }
diff --git a/run_tests.sh b/run_tests.sh
index 6f23651..9f21be9 100755
--- a/run_tests.sh
+++ b/run_tests.sh
@@ -9,4 +9,4 @@ cargo test --manifest-path "$workspace_cargo_manifest" --workspace --exclude e2e
 
 # So that we may have a binary in `target/release`
 cargo build --release --manifest-path "$workspace_cargo_manifest" --bin fuel-block-committer
-PATH="$script_location/target/release:$PATH" cargo test --manifest-path "$workspace_cargo_manifest" --package e2e --jobs 1
+PATH="$script_location/target/release:$PATH" cargo test --manifest-path "$workspace_cargo_manifest" --package e2e
