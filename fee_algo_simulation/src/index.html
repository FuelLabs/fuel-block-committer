<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Fee Algo Simulator</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <!-- Plotly JS -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js" integrity="sha384-kIW8v2UtFMvKjRSuXvClzSkXUW9Yw38cOFK6iSkOgBbm425jZL8Fp2X15blqjcTI" crossorigin="anonymous"></script>
  <style>
    /* Custom Styles */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f8f9fa;
    }
    #chart {
      width: 100%;
      height: 600px;
    }
    .stats {
      margin-top: 20px;
    }
    @media (max-width: 768px) {
      #chart {
        height: 400px;
      }
    }
    #loading {
      display: none;
      font-weight: bold;
      color: #555;
    }
    .required::after {
      content: " *";
      color: red;
    }
    /* Simulation plot sizes */
    #simPricePlot, #simBacklogPlot {
      width: 100%;
      height: 400px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="mb-4 text-center">Fee Algo Simulator</h1>

    <!-- Input Form -->
    <div class="card mb-4">
      <div class="card-body">
        <form id="feeForm">
          <div class="row mb-3">
            <div class="col-md-4">
              <label for="endingHeight" class="form-label">Ending Height:</label>
              <input type="number" class="form-control" id="endingHeight" placeholder="Leave empty for latest height" />
            </div>
            <div class="col-md-4">
              <label for="amountOfBlocks" class="form-label required">Block Range:</label>
              <input type="number" class="form-control" id="amountOfBlocks" value="900" required />
            </div>
            <div class="col-md-4">
              <label for="numBlobs" class="form-label required">Number of Blobs:</label>
              <input type="number" class="form-control" id="numBlobs" value="6" min="1" max="6" required />
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="short" class="form-label required">Short SMA (blocks):</label>
              <input type="number" class="form-control" id="short" value="25" required />
            </div>
            <div class="col-md-6">
              <label for="long" class="form-label required">Long SMA (blocks):</label>
              <input type="number" class="form-control" id="long" value="900" required />
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="maxL2" class="form-label required">Max L2 Blocks Behind:</label>
              <input type="number" class="form-control" id="maxL2" value="28800" required />
              <div class="form-text">e.g., 8 hours worth</div>
            </div>
            <div class="col-md-6">
              <label for="l2Behind" class="form-label required">Number of L2 Blocks Behind:</label>
              <input type="number" class="form-control" id="l2Behind" value="0" required />
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="startMultiplier" class="form-label required">Start Max Fee Multiplier:</label>
              <input type="number" step="0.000001" class="form-control" id="startMultiplier" value="0.800000" required />
              <div class="form-text">Multiplier applied to long-term SMA fee at start (e.g., 0.8 = 80%)</div>
            </div>
            <div class="col-md-6">
              <label for="endMultiplier" class="form-label required">End Max Fee Multiplier:</label>
              <input type="number" step="0.000001" class="form-control" id="endMultiplier" value="1.200000" required />
              <div class="form-text">Multiplier applied to long-term SMA fee at end (e.g., 1.05 = 105%)</div>
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="alwaysAcceptable" class="form-label required">Always Acceptable Fee:</label>
              <input type="number" class="form-control" id="alwaysAcceptable" value="1000000000000000" required />
              <div class="form-text">Value in Wei (e.g., 1 ETH = 1,000,000,000,000,000,000 Wei)</div>
            </div>
          </div>

          <!-- Preset Buttons -->
          <div class="mb-3">
            <button type="button" class="btn btn-primary me-2" onclick="setPreset(216000)">Last 1 Month (~216k blocks)</button>
            <button type="button" class="btn btn-primary me-2" onclick="setPreset(50400)">Last 1 Week (~50.4k blocks)</button>
            <button type="button" class="btn btn-primary me-2" onclick="setPreset(21600)">Last 3 Days (~21.6k blocks)</button>
            <button type="button" class="btn btn-primary me-2" onclick="setPreset(7200)">Last 1 Day (~7.2k blocks)</button>
            <button type="button" class="btn btn-primary me-2" onclick="setPreset(1500)">Last 5 Hours (~1.5k blocks)</button>
            <button type="button" class="btn btn-secondary" onclick="resetFields()">Reset</button>
          </div>

          <!-- Simulation Settings -->
          <div class="card mb-4">
            <div class="card-body">
              <h2 class="card-title">Simulation Settings</h2>
              <div class="row mb-3">
                <div class="col-md-6">
                  <label for="blobCount" class="form-label required">Blobs per Interval:</label>
                  <input type="number" class="form-control" id="blobCount" value="6" required />
                </div>
                <div class="col-md-6">
                  <label for="blobInterval" class="form-label required">Interval (minutes):</label>
                  <input type="number" class="form-control" id="blobInterval" value="60" required />
                </div>
              </div>
              <button type="button" class="btn btn-success" onclick="fetchAndSimulate()">Run Simulation</button>
            </div>
          </div>
        </form>
      </div>
    </div>

    <!-- Chart Area (Fee Graph) -->
    <div class="card mb-4">
      <div class="card-body">
        <div id="chart"></div>
      </div>
    </div>

    <!-- Statistics Section -->
    <div class="card mb-4">
      <div class="card-body stats">
        <h2 class="card-title">Statistics</h2>
        <div class="row">
          <div class="col-md-4 mb-3">
            <div class="alert alert-info" role="alert">
              <strong>Percentage of Acceptable Blocks:</strong> <span id="percentageAcceptable">0%</span>
            </div>
          </div>
          <div class="col-md-4 mb-3">
            <div class="alert alert-warning" role="alert">
              <strong>95th Percentile of Gap Sizes:</strong> <span id="percentile95GapSize">0 blocks</span>
            </div>
          </div>
          <div class="col-md-4 mb-3">
            <div class="alert alert-danger" role="alert">
              <strong>Longest Unacceptable Streak:</strong> <span id="longestUnacceptableStreak">0 blocks</span>
            </div>
          </div>
        </div>
        <div id="loading" class="text-center">
          <div class="spinner-border text-secondary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p>Loading...</p>
        </div>
      </div>
    </div>

    <!-- Simulation Results Section -->
    <div class="card mb-4">
      <div class="card-body">
        <h2 class="card-title">Simulation Results</h2>
        <p>Immediate Commit Total Fee: <span id="simImmediateFee">0</span> ETH</p>
        <p>Algorithm-driven Commit Total Fee: <span id="simAlgorithmFee">0</span> ETH</p>
        <p>ETH Saved: <span id="simEthSaved">0</span> ETH</p>
        <!-- These divs will hold our simulation plots -->
        <div id="simPricePlot"></div>
        <div id="simBacklogPlot"></div>
      </div>
    </div>
  </div>

  <script>
    /**
     * Sets the block range to a preset value and fetches new data.
     * @param {number} numBlocks - Number of blocks to set.
     */
    function setPreset(numBlocks) {
      document.getElementById('amountOfBlocks').value = numBlocks;
      fetchAndPlot();
    }

    /**
     * Resets all input fields to their default values and fetches data.
     */
    function resetFields() {
      document.getElementById('feeForm').reset();
      document.getElementById('endingHeight').value = "";
      document.getElementById('amountOfBlocks').value = "300";
      document.getElementById('short').value = "25";
      document.getElementById('long').value = "300";
      document.getElementById('maxL2').value = "28800";
      document.getElementById('startMultiplier').value = "0.800000";
      document.getElementById('endMultiplier').value = "1.200000";
      document.getElementById('alwaysAcceptable').value = "1000000000000000";
      document.getElementById('numBlobs').value = "6";
      document.getElementById('l2Behind').value = "0";
      fetchAndPlot();
    }

    /**
     * Identifies acceptable regions based on block data.
     * @param {Array} data - Array of FeeDataPoint objects.
     * @returns {Array} - Array of regions with start and end block heights.
     */
    function getAcceptableRegions(data) {
      let regions = [];
      let start = null;

      for (let i = 0; i < data.length; i++) {
        if (data[i].acceptable) {
          if (start === null) {
            start = data[i].blockHeight;
          }
        } else {
          if (start !== null) {
            regions.push({ start: start, end: data[i - 1].blockHeight });
            start = null;
          }
        }
      }
      if (start !== null) {
        regions.push({ start: start, end: data[data.length - 1].blockHeight });
      }
      return regions;
    }

    /**
     * Fetches fee data from the server and plots it using Plotly.
     */
    async function fetchAndPlot() {
      const endingHeightInput = document.getElementById('endingHeight');
      const endingHeightValue = endingHeightInput.value ? parseInt(endingHeightInput.value, 10) : null;
      const amountOfBlocks     = parseInt(document.getElementById('amountOfBlocks').value, 10);
      const shortSma           = parseInt(document.getElementById('short').value, 10);
      const longSma            = parseInt(document.getElementById('long').value, 10);
      const maxL2              = parseInt(document.getElementById('maxL2').value, 10);
      const startMultiplier    = parseFloat(document.getElementById('startMultiplier').value);
      const endMultiplier      = parseFloat(document.getElementById('endMultiplier').value);
      const alwaysAcceptable   = document.getElementById('alwaysAcceptable').value;
      const numBlobs           = parseInt(document.getElementById('numBlobs').value, 10);
      const numL2BlocksBehind  = parseInt(document.getElementById('l2Behind').value, 10);

      if (isNaN(amountOfBlocks) || isNaN(shortSma) || isNaN(longSma) ||
          isNaN(maxL2) || isNaN(startMultiplier) || isNaN(endMultiplier) ||
          isNaN(numBlobs) || isNaN(numL2BlocksBehind)) {
        alert('Please ensure all input fields are filled out correctly.');
        return;
      }
      if (numBlobs < 1 || numBlobs > 6) {
        alert('Number of Blobs must be between 1 and 6.');
        return;
      }
      if (startMultiplier <= 0 || endMultiplier <= 0) {
        alert('Multipliers must be greater than 0.');
        return;
      }

      document.getElementById('loading').style.display = 'block';

      const params = {
        amount_of_blocks: amountOfBlocks,
        short: shortSma,
        long: longSma,
        max_l2_blocks_behind: maxL2,
        start_max_fee_multiplier: startMultiplier,
        end_max_fee_multiplier: endMultiplier,
        always_acceptable_fee: alwaysAcceptable,
        num_blobs: numBlobs,
        num_l2_blocks_behind: numL2BlocksBehind,
      };
      if (endingHeightValue !== null && !isNaN(endingHeightValue)) {
        params.ending_height = endingHeightValue;
      }

      const qs = new URLSearchParams(params).toString();
      const url = '/fees?' + qs;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`Error: ${resp.status}`);
        }
        const response = await resp.json();
        const data = response.data;
        const stats = response.stats;

        if (endingHeightValue === null) {
          const maxBlockHeight = data.reduce((max, d) => d.blockHeight > max ? d.blockHeight : max, 0);
          if (maxBlockHeight > 0) {
            endingHeightInput.value = maxBlockHeight;
          }
        }
        document.getElementById('percentageAcceptable').innerText = `${stats.percentageAcceptable.toFixed(2)}%`;
        document.getElementById('percentile95GapSize').innerText = `${stats.percentile95GapSize} blocks`;
        document.getElementById('longestUnacceptableStreak').innerText = `${stats.longestUnacceptableStreak} blocks`;

        const x = data.map(d => d.blockTime);
        const currentFees = data.map(d => parseFloat(d.currentFee).toFixed(6));
        const shortFees   = data.map(d => parseFloat(d.shortFee).toFixed(6));
        const longFees    = data.map(d => parseFloat(d.longFee).toFixed(6));
        const acceptableRegions = getAcceptableRegions(data);
        const shapes = acceptableRegions.map(region => {
          const startBlock = data.find(d => d.blockHeight === region.start);
          const endBlock = data.find(d => d.blockHeight === region.end);
          const x0 = startBlock ? startBlock.blockTime : null;
          const x1 = endBlock ? endBlock.blockTime : null;
          if (x0 && x1) {
            return {
              type: 'rect',
              xref: 'x',
              yref: 'paper',
              x0: x0,
              y0: 0,
              x1: x1,
              y1: 1,
              fillcolor: 'rgba(0, 255, 0, 0.2)',
              line: { width: 0 },
            };
          } else {
            return null;
          }
        }).filter(shape => shape !== null);

        const traceCurrent = {
          x, 
          y: currentFees,
          mode: 'lines',
          name: 'Current Fee (ETH)',
          line: {color: 'blue'},
          hoverinfo: 'x+y',
        };
        const traceShort = {
          x,
          y: shortFees,
          mode: 'lines',
          name: 'Short SMA Fee (ETH)',
          line: {color: 'red'},
          hoverinfo: 'x+y',
        };
        const traceLong = {
          x,
          y: longFees,
          mode: 'lines',
          name: 'Long SMA Fee (ETH)',
          line: {color: 'green'},
          hoverinfo: 'x+y',
        };
        const layout = {
          title: 'Fees vs. Block Time',
          titlefont: { size: 20 },
          xaxis: { title: 'Block Time (UTC)', type: 'date', tickformat: '%Y-%m-%d %H:%M:%S' },
          yaxis: { title: 'Fee (ETH)', tickformat: '.6f' },
          legend: { orientation: 'h', x: 0, y: 1.1 },
          shapes: shapes,
        };

        Plotly.newPlot('chart', [traceCurrent, traceShort, traceLong], layout);
      } catch (err) {
        document.getElementById('percentageAcceptable').innerText = `Error: ${err.message}`;
        document.getElementById('percentile95GapSize').innerText = `-`;
        document.getElementById('longestUnacceptableStreak').innerText = `-`;
        Plotly.purge('chart');
        console.error(err);
        alert('Failed to fetch data. Please check your inputs and try again.');
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    /**
     * Fetches simulation data from the server using a POST request with a JSON body and displays the results,
     * including two plots: one for cumulative fee over time and one for backlog over time.
     */
    async function fetchAndSimulate() {
      const endingHeightInput = document.getElementById('endingHeight');
      const endingHeightValue = endingHeightInput.value ? parseInt(endingHeightInput.value, 10) : null;
      const amountOfBlocks     = parseInt(document.getElementById('amountOfBlocks').value, 10);
      const shortSma           = parseInt(document.getElementById('short').value, 10);
      const longSma            = parseInt(document.getElementById('long').value, 10);
      const maxL2              = parseInt(document.getElementById('maxL2').value, 10);
      const startMultiplier    = parseFloat(document.getElementById('startMultiplier').value);
      const endMultiplier      = parseFloat(document.getElementById('endMultiplier').value);
      const alwaysAcceptable   = document.getElementById('alwaysAcceptable').value;
      const numBlobs           = parseInt(document.getElementById('numBlobs').value, 10);
      const numL2BlocksBehind  = parseInt(document.getElementById('l2Behind').value, 10);
      const blobCount          = parseInt(document.getElementById('blobCount').value, 10);
      const blobInterval       = parseInt(document.getElementById('blobInterval').value, 10);

      if (isNaN(amountOfBlocks) || isNaN(shortSma) || isNaN(longSma) ||
          isNaN(maxL2) || isNaN(startMultiplier) || isNaN(endMultiplier) ||
          isNaN(numBlobs) || isNaN(numL2BlocksBehind) ||
          isNaN(blobCount) || isNaN(blobInterval)) {
        alert('Please ensure all input fields are filled out correctly.');
        return;
      }

      let simData = {
        amount_of_blocks: amountOfBlocks,
        short: shortSma,
        long: longSma,
        max_l2_blocks_behind: maxL2,
        start_max_fee_multiplier: startMultiplier,
        end_max_fee_multiplier: endMultiplier,
        always_acceptable_fee: alwaysAcceptable,
        num_blobs: numBlobs,
        num_l2_blocks_behind: numL2BlocksBehind,
        blob_count: blobCount,
        blob_interval_minutes: blobInterval
      };
      if (endingHeightValue !== null && !isNaN(endingHeightValue)) {
        simData.ending_height = endingHeightValue;
      }

      try {
        const resp = await fetch('/simulate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(simData)
        });
        if (!resp.ok) {
          throw new Error(`Error: ${resp.status}`);
        }
        const simResult = await resp.json();
        document.getElementById('simImmediateFee').innerText = simResult.immediate_total_fee.toFixed(6);
        document.getElementById('simAlgorithmFee').innerText = simResult.algorithm_total_fee.toFixed(6);
        document.getElementById('simEthSaved').innerText = simResult.eth_saved.toFixed(6);

        // Extract timeline data for plotting.
        const timeline = simResult.timeline;
        const times = timeline.map(point => point.time);
        const immediateFees = timeline.map(point => point.immediate_fee);
        const algorithmFees = timeline.map(point => point.algorithm_fee);
        const backlogs = timeline.map(point => point.backlog);

        // Price Paid Plot (cumulative fees over time)
        const priceTraceImmediate = {
          x: times,
          y: immediateFees,
          mode: 'lines',
          name: 'Immediate Fee'
        };
        const priceTraceAlgorithm = {
          x: times,
          y: algorithmFees,
          mode: 'lines',
          name: 'Algorithm Fee'
        };
        const priceLayout = {
          title: 'Cumulative Fee Paid Over Time',
          xaxis: { title: 'Time', type: 'date' },
          yaxis: { title: 'Fee (ETH)' }
        };
        Plotly.newPlot('simPricePlot', [priceTraceImmediate, priceTraceAlgorithm], priceLayout);

        // Backlog Plot
        const backlogTrace = {
          x: times,
          y: backlogs,
          mode: 'lines+markers',
          name: 'Backlog'
        };
        const backlogLayout = {
          title: 'Blob Backlog Over Time',
          xaxis: { title: 'Time', type: 'date' },
          yaxis: { title: 'Number of Blobs in Backlog' }
        };
        Plotly.newPlot('simBacklogPlot', [backlogTrace], backlogLayout);
      } catch (err) {
        alert('Simulation failed: ' + err.message);
        console.error(err);
      }
    }

    // Immediately plot once on page load
    fetchAndPlot();
  </script>
</body>
</html>
